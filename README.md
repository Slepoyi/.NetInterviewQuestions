# Вопросы с собеседований на .NET-разработчика
Здесь собраны вопросы, которые могут задать разработчику .NET на собеседовании. На каждый вопрос есть краткий (или не очень) ответ. 

## Платформа .NET
<details>
    <summary>Как устроена память в C#</summary>
Область памяти в каждом домене приложения делится на системную:

1. Таблица типов
заполнена специальными объектами, наследниками RuntimeType. Каждый тип состоит из статической и экземплярной части. При первом упоминании типа в выполняемом виртуально машиной выражении, его статическая часть размещается в таблице 

2. Список блоков синхронизации
набор системных блоков синхронизации.  При необходимости синхронизации многопоточный работы, CLR создает блок синхронизации. Блок содержит слабую ссылку на объект синхронизации (слабую, потому что объект может быть удален GC несмотря на ссылку) и ссылку на монитор. Именно эти блоки и лежат в таблице. Для большинства объектов блок синхронизации не создается в принципе. 

3. Пул строк
заполнен интернированными строками и строковыми константами

4. Пул потоков
пул потоков виртуальной машины

5. Прочее
некоторые заранее выделенные переменные (OutOfMemoryException), отображение системных ресурсов

И пользовательскую:

6. Small Object Heap
куча, на которой живут объекты меньше 85к байт. Разделена на 3 поколения. При достижении лимита памяти для поколения происходит сборка мусора.

7. Large Object Heap
куча больших объектов (больше 85к байт), не разделена на поколения, собирается по правилам поколения 2.

8. Pinned Object Heap
куча для закрепленных объектов. В текущей версии поддерживает только выделение на ней массивов «непреобразуемых» типов. Специфична, используется очень редко, как таковая внимания не требует.

9. Стек
тут выделяется память под стек приложения

Есть типы двух видов - ссылочные и значимые. Значимые лежат на стеке (стек быстро работает). Ссылочные хранятся на куче (куча медленнее), а на стеке лежит ссылка на область памяти в куче. Стек метода очищается после завершения метода. Куча очищается сборщиком мусора.
</details>

<details>
    <summary>
        Сборка мусора в .NET
    </summary>
    
Это процесс освобождения памяти сборщиком мусора (Garbage Collector, GC). Запускается тогда, когда CLR посчитает это необходимым (недостаточно физической памяти в системе, используемая память в управляемой куче вышла за текущий порог), но можно вызвать вручную (GC.Collect).

Всего 3 поколения сборки мусора. Если объект пережил сборку мусора, то он переходит на поколение выше (пока есть куда). Сборщик начинает с поколения 0, часть очищает, часть переводит в поколение 1. Если память все еще нужна, GC берется за первое поколение.

Т.к. куча сильно фрагментирована, после очистки памяти происходит уплотнение (сжатие) кучи и обновление ссылок. Куча сжимается всегда для 0 и 1 поколений. Для 2 поколения куча сжимается реже (частота зависит от вида сборки мусора). Уплотнение LOH обычно не происходит, это зависит от настроек и от давления сборщика мусора.

Есть 2 вида работы сборщика мусора: серверная и клиентская.

Клиентская предназначена для работы на клиентских приложениях (например, десктопные приложения, UI-клиенты). Сборка мусора происходит одним потоком.
0 и 1 поколение собираются асинхронно. Поколение 2 собирается с остановкой всех потоков (stop-the-world), но оптимизировано под короткие паузы.
LOH редко уплотняется.
Серверная предназначена для работы на серверных приложениях (бэкенд). 
Все поколения собираются синхронно. Для ускорения сборки мусора выделяется 1 поток на каждое ядро CPU (следовательно, масштабируется за счет увеличения числа ядер CPU), каждому потоку выделена своя куча.
LOH сжимается только в сценариях высокого давления сборщика мусора. 
В целом уплотнения кучи происходят реже для того, чтобы сборки мусора были как можно более быстрыми.

Давлением сборщика мусора называется ситуация, когда объекты создаются настолько часто, что сборщик мусора не успевает их подчищать. Это приводит к частым сборкам мусора и увеличению задержки приложения.
Вызываются излишними аллокациями в куче как небольших, так и больших объектов. Из-за этого увеличивается фрагментация кучи, часто собираются объекты 2 поколения (помним про stop-the-world).
В таком случае нужно смотреть на:
- возможно, где-то в приложении происходят лишние аллокации (боксинг, конкатенация большого числа строк, т.д.)
- на куче аллоцируется много короткоживущих объектов (подумать о замене их на структуры)
- "арендовать" массивы из пула (ArrayPool.Rent), если нужно часто работать с большими массивами
- некорректная настройка GC (workstation для сервера)

Сборщик мусора проходится по корням (участки памяти, в силу определенных причин доступные всегда и содержащие ссылки на объекты, созданные программой), затем просматривает объекты, на которые они ссылаются, и помечает их живыми. Когда все живые объекты определены, все остальное можно очистить, а кучу уплотнить.

>Примечание: объекты LOH собираются как объекты поколения 2.

Корни сами по себе не объекты, а ссылки на них. Любой объект, на который ссылается корень, переживет следующую сборку мусора. Корнями являются:
1. Локальные переменные ссылочного типа в текущем методе
2. Статические поля
3. Управляемые объекты, переданные через ```Interop```
4. Ссылки на объекты с финализатором

</details>

<details>
    <summary>
        В чем разница между процессом и потоком?
    </summary>
    
Процесс - контейнер, в котором запущено приложение 

Поток - воркер, который работает внутри процесса и выполняет непосредственную работу; независимый путь выполнения, который может выполняться одновременно с другими

</details>


<details>
    <summary>
    Что такое AppDomain?
    </summary>
    Это контейнер, внутри которого работает приложение, и который изолирует ее в рантайме; 1 процесс размещает 1 домен (обычно)
</details>

<details>
    <summary>
        Что такое утечка памяти? Как получить ее в .NET
    </summary>
    Утечка памяти - неконтролируемый рост потребления памяти приложением.

Глобально 2 причины: 

1. Неиспользуемые объекты, на которые остались ссылки
    - подписка на событие: если не отписаться, получится, что событие удерживает ссылку на обработчик.
    - захват членов класса лямбдой
    - статические переменные и все, на что они ссылаются, не будут очищены
    - бесконтрольное кэширование без очистки кэша
    - потоки, которые никогда не останавливаются

2. Неаккуратная работа с неуправляемой памятью
    - не освобожденная неуправляемая память
    - не вызванный Dispose у IDisposable (решением является паттерн реализации Dispose)
</details>

## Базовый функционал
<details>
    <summary>
         Records - что это, для чего ввели
    </summary>
    Ключевые особенности:
- сравнение работает по свойствам а не ссылкам
- можно создавать с помощью with
- позиционность (public record A(int B) создаёт конструктор и деконструктор)
- ToString выводит отформатированный объект
</details>

<details>
<summary>Ключевое слово static и его особенности</summary>
Ключевое слово static помечает член типа статическим. Статические члены типа не принадлежат экземпляру, а принадлежат типу целиком. 1 раз создаются и живут до конца жизни приложения (если не присвоить им null, тогда их соберет ```GC```).
Статический класс может содержать только статические члены. Экземпляр такого класса создать нельзя. Статический конструктор используется для инициализации любых статических данных или для выполнения определенного действия, которое требуется выполнить только один раз. Он вызывается автоматически перед созданием первого экземпляра или ссылкой на какие-либо статические члены. Статический конструктор будет вызываться не более одного раза.
</details>

<details>
    <summary>
        Паттерн Dispose
    </summary>

Паттерн нужен для того, чтобы гарантировать очистку неуправляемых ресурсов и выглядит примерно так:

```
public class Resource : IDisposable
{
    private IntPtr _handle;

    public void Dispose()
    {
        ReleaseHandle(_handle);
        GC.SuppressFinalize(this);
    }

    ~Resource() => ReleaseHandle(_handle);
}
```

SuppressFinalize необходим для того, чтобы пропустить вызов финализатора у объекта. Так объект не попадет в очередь финализации, что снижает нагрузку на GC.

В таком виде (или усложненных модификациях) паттерн требуется только при ручном создании экземпляров Resource. Если же речь про DI, то контейнер сам вызовет Dispose у объекта и можно обойтись без финализатора (и без SuppressFinalize).
</details>

<details>
    <summary>
         Внедрение зависимостей
    </summary>
    
В ASP .NET Core существует встроенный контейнер для внедрения зависимостей. Зависимости делятся на 3 типа: Transient (создаются каждый раз по требованию), Scoped (создаются единожды для скоупа), Singleton (создаются единожды и живут пока работает приложение).
    
Можно внедрить Singleton в Scoped и Scoped в Transient, а также зависимости одного типа друг в друга без проблем.
    
Transient можно внудрить в Scoped или Singleton, но тогда Transient окажется захвачен "родительским" объектом и будет жить столько же, сколько живет он.
    
Scoped нельзя внедрить в Singleton, потому что Scoped часто пологается на данные конкретного скоупа (например, HttpRequest, DbContext). Если же внедрить Scoped в Singleton, он будет захвачен и эти данные из скоупа не смогут обновиться. Это приведет к поломанному состоянию, race condition и т.д.
</details>

<details>
    <summary>
        Разница между абстрактным классом и интерфейсом
    </summary>

|  | Абстрактный класс | Интерфейс | 
| ----------- | ----------- | ----------- |
| Множественное наследование/реализация | В C# нет множественного наследования | В C# можно реализовать множество интерфесов |
| "Абстрактные" методы | Абстрактный класс может содержать абстрактные методы | По сути все методы интерфейса "абстрактны" как контракты, хоть и не содержат ключевого слова "abstract". Однако, начиная с C# 8 интерфейсы могут иметь реализацию по умолчанию.
| Состояние | Может иметь поля и свойства | Может иметь только свойства (нет полей) |
| Наличие конструктора | + | - |
| Возможность наличия статических членов | + | - |
| Модификаторы доступа | Может содержать разные модификаторы доступа | Все методы и свойства интерфейса публичны |
| Строгость контракта |  Обязательно переопределить все абстрактные методы, виртуальные по желанию | Обязательно реализовать все методы интерфейса |
| Когда применять | Абстрактный класс используется для выделения общего поведения, классов одной иерархии | Интерфейс используется для выделения общего функционала в классах разной иерархии |

</details>

<details>
    <summary>
        Статический класс vs singleton vs DI singleton
    </summary>

|  | Статический класс | Singleton | DI singleton | 
| ----------- | ----------- | ----------- | ----------- |
| Ленивость | Нет | Есть, но можно потерять (положив инстанс в DI) | Есть |
| Работа с зависимостями | Проблемно | Проблемно | Легко |
| Управление состоянием | Сложно следить | Нормально | Нормально |
| Реализация интерфейса | - | + | + |
| Наследование | - | + | + |

Выводы:
Статические классы следует использовать только для утилитарных вещей (например, методы расширений или бизнес логики). Для всего остального лучше использовать синглтон (меньше шансов отстрелить себе ногу).

</details>

<details>
    <summary>
        Какой тип возвращает GetHashCode
    </summary>
    Int
</details>

<details>
    <summary>
        Что работает быстрее - класс или структура.
    </summary>
    Во-первых, «быстрее» будет не наверняка. Например, если нужно передавать в метод данные, то не факт, что передача ссылки на класс будет медленнее, чем копирование структуры.

Во-вторых, если нужен просто доступ к данным небольшого локального объекта, то структура будет быстрее за счет хранения на стеке (стек работает быстрее кучи)
</details>

<details>
    <summary>
        Если заменить класс на структуру (слово class на struct в декларации) и попытаться скомпилировать - будут ли ошибки? Если да, то какие
    </summary>
    Код не скомпилируется, если:
    
- есть наследование от класса (т.к. наследовать от структуры нельзя)
- есть деструктор (финализатор) класса (в структурах их нет)
- есть конструктор без параметров, которые запрещены в структурах в старых версиях C# (хотя сейчас можно)
- указаны значения полей по умолчанию (в структурах нельзя указывать значение по умолчанию для полей в старых версиях C# (сейчас можно))
</details>

<details>
    <summary>
        Когда использовать класс, а когда структуры?
    </summary>
    
Структура, как правило, представляет собой неизменяемые объекты с семантикой значения. Например, координата,  деньги, классическая дробь и т.п.

Из-за их семантики и передачи по значению, их можно использовать в сценариях с высокой нагрузкой, когда создается много объектов и важно максимально снизить давление GC.
Это могут быть ключи для кэширования, небольшие объекты для внутренних вычислений.

Надо следить за размером структур, не делать их слишком большими. По рекомендациям Microsoft это не более 16 байт, но следует смотреть по производительности. Из-за копирования при передаче структур, слишком большие структуры могут замедлять работу приложения.

Общий совет - использовать классы, пока на 99% не уверен, что нужна структура и что она ускорит выполнение.
</details>

<details>
    <summary>
        Object и System.ValueType
    </summary>

Object - базовый класс для всех типов в C#. Имеет следующие методы - GetType, Equals, GetHashCode, ToString (последние 3 из них - переопределяемые).

ValueType - наследник Object. От него наследуются все типы, которые должны вести себя как значимые - struct, enum. Все встроенные значимые типы (bool, int, float и т.п. - на самом деле структуры).

Суть различий - поведение при создании новых объектов (копирование у значимых типов и передача ссылки у ссылочных), выделение памяти под типы (на стеке у значимых, на куче у ссылочных).

Различия между Object и ValueType проявляются в рантайме, т.к. рантайм по-особому относится к ValueType.

Чтобы убрать это различие, ValueType можно привести к типу Object (боксинг), обратная операция каста Object к ValueType называется анбоксинг. 
    
</details>


<details>
    <summary>
        Делегаты, события
    </summary>
    Делегаты - это объекты, указывающие на методы. Методы имеют определенную делегатом сигнатуру, один делегат может указывать на много методов. Под капотом - класс, содержащий в себе сигнатуру метода.

Делегаты можно объединять (определена операция +, есть и -). Если делегат возвращает значение, то значение вернется из последнего метода в списке методов делегата. Если попытаться вызвать делегат, в котором нет методов, получим исключение.

Есть делегаты трех типов - Action, Func и Predicate: 

- Action - действие, которое ничего не возвращает
- Predicate - принимает 1 параметр и возвращает bool
- Func - возвращает результат действия, принимает параметры.

Событие - объект, "представляющий" делегат. В событие добавляются обработчики типа, который определен делегатом. Под капотом - класс с методами Add и Remove, а также полем типа делегата. Методы Add и Remove добавляют и удаляют методы в делегат.

С точки зрения программиста отличия такие:

- событие может быть вызвано только в том классе, где объявлено
- события не могут быть локальной переменной, а делегаты могут
</details>

<details>
    <summary>
        Как работает финализатор
    </summary>

Точное время вызова не определено. ```GC``` смотрит, поддерживает ли объект ```Finalize```. Если да, то помещает указатель на него в специальную очередь финализации. В момент сборки мусора ```GC``` видит, что объект нужно уничтожить и, если у него есть ```Finalize```, то он копируется в еще одну таблицу и будет уничтожен только при следующей сборке мусора.
</details>

<details>
    <summary>
        Дженерики
    </summary>
    
Дженерики - это фича, позволяющая писать классы и методы, используя заглушку вместо типа, а реальный тип будет определен в процессе использования данного класса или метода.

Пример:
```List<int> list = new List<int>();```

Плюсы:
- типобезопасность (тип определяется в компайл-тайме)
- переиспользование кода
- отсутствие боксинга/анбоксинга

Для value-type компилятор генерирует отдельные реализации дженериков. Для reference-type реализация одна.

Часто используются ограничения на параметр T:

- ```where T : struct``` - ```T``` должен быть value-type
- ```where T : new()``` - ```T``` должен содержать публичный конструктор без параметров
- ```where T : IComparable<T>``` - ```T``` должен реализовать интерфейс ```IComparable<T>```

В дженериках можно использовать ключевые слова ```in``` и ```out```.
Ключевое слово ```out``` включает ковариантность.

```
class Message
{
    public string Text { get; set; }
}
class EmailMessage : Message { }

interface IMessenger<out T>
{
    T WriteMessage(string text);
}
class EmailMessenger : IMessenger<EmailMessage>
{
    public EmailMessage WriteMessage(string text)
    {
        return new EmailMessage($"Email: {text}");
    }
}
```

Использование

```IMessenger<Message> outlook = new EmailMessenger();```

То есть более общему типу ```IMessenger<Message>``` можно присвоить более частный ```IMessenger<EmailMessage>```. Без использования out такой код не скомпилируется.

Ключевое слово ```in``` включает контравариантность.

```
interface IMessenger<in T>
{
    void SendMessage(T message);
}
class SimpleMessenger : IMessenger<Message>
{
    public void SendMessage(Message message)
    {
        Console.WriteLine($"Отправляется сообщение: {message.Text}");
    }
}
```

Использование:

```IMessenger<EmailMessage> outlook = new SimpleMessenger();```

Здесь более частному типу присваивается более общий. Аналогично, код без ```in``` не скомпилируется.

</details>


<details>
    <summary>
        Статьи
    </summary>
    
1. [Делегаты func, action, predicate - Метанит](https://metanit.com/sharp/tutorial/3.33.php)
2. [Делегаты и события - StackOverflow](https://ru.stackoverflow.com/questions/226505/event-и-delegate-в-чем-отличие)
3. [Делегаты и события - StackOverflow](https://stackoverflow.com/questions/29155/what-are-the-differences-between-delegates-and-events)
4. [Ковариантность и контравариантность в обобщенных интерфейсах](https://metanit.com/sharp/tutorial/3.27.php)
</details>

## Коллекции
<details>
<summary>IEnumerable - что это, как работает</summary>
Интерфейс, который используется для простого перебора коллекции (проход в одну сторону).

Реализует метод ```GetEnumerator```, который возвращает ```Enumerator```. ```Enumerator``` в свою очередь предоставляет свойство ```Current```, а также методы ```MoveNext``` и ```Reset``` для движения по коллекции.
</details>

<details>
<summary>
    Как реализован словарь?
</summary>

Внутри лежит 2 массива: ```Entry``` и ```buckets```. При добавлении элемента вычисляется индекс корзины, в которую его добавят: ```(hashcode & 0x7fffffff) % capacity```.

Если такой ключ уже есть, то ```Add``` выбросит исключение, а присваивание по индексу просто заменит элемент. Если массив заполнен, происходит расширение.

Если происходит коллизия (в ```buckets``` есть элемент с индексом), то новый элемент добавляется в коллекцию, его индекс пишется в корзину, а индекс старого - в поле ```next``` нового.

Если число коллизий велико (больше 100), происходит перехэширование с выбором нового генератора хэш-кодов.

</details>
    
<details>
    <summary>Как работает Array.Resize</summary>
Создает новый массив нужной длины и копирует туда текущий
</details>

<details>
    <summary>Как реализован List</summary>
Под капотом лежит массив и счетчик. При добавлении элемента элемент записывается в свободную ячейку массива и счетчик увеличивается.

Если свободных ячеек нет, массив ресайзится. Если знаем, что будет добавлено определенное кол-во элементов, можно установить начальную емкость, чтобы избежать частого ресайза.
</details>

<details>
<summary>IQueryable - что это, как работает</summary>
Интерфейс, используемый для работы с данными в источнике данных. Расширяет возможности IQueryable (реализует его) Конструирует expression tree, которое выражает запрос, и передает его LINQ-провайдеру, транслирующему дерево в запрос непосредственно к источнику данных.

> Важно: один и тот же запрос может быть корректно оттранслирован одним провайдером и не оттранслирован другим; узнать об этом можно только в рантайме.
</details>

<details>
<summary>
    IEnumerable vs IQueryable
</summary>
    
```IEnumerable``` работает в памяти; при фильтрации ```IEnumerable``` отфильтрует записи по предикату в цикле ```foreach```. Запрос выполняется «в лоб». В методах расширения уже есть логика обработки данных.

```IQueryable``` конструирует запрос, отправляет его в источник данных и отдает полученные данные. Запрос будет оптимизирован. Логики обработки данных в расширениях нет.

</details>

## Многопоточное/асинхронное программирование
<details>
<summary>
    В чем разница между Task и Thread?
</summary>

**Поток** - низкоуровневая абстракция, непосредственно поток выполнения (путь выполнения), который можно переиспользовать.
**Задача** - высокоуровневая абстракция, «обещание» выполнения переданного кода. Код выполняется на потоке. О выполнении заботится ```TaskScheduler```.

</details>

<details>
<summary>Что такое критическая секция</summary>
Любая секция кода, одновременный доступ к которой мы хотим разрешить только одному потоку.
</details>

<details>
<summary>
    Monitor, lock, Mutex
</summary>
    
```Monitor``` - класс, реализующий идею критической секции. 

```lock``` - синтаксический сахар над ```Monitor.Enter``` и ```Monitor.Exit```, как и ```using```, разворачивается компилятором в ```try..finally```.

```Mutex``` - объект операционной системы, который можно использовать для межпроцессной синхронизации.

Внутри блокировки ```Monitor``` (и ```lock```) нельзя использовать ```await```, потому что код после await совсем не обязательно будет выполнен на том же поток, на котором код до. Следовательно, ```Enter``` будет вызван одним потоком, ```Exit``` - другим, получим исключение синхронизации.

```Monitor``` (и ```lock```) используют комбинированный подход к блокировке (небольшое ожидание быстрого взятия блокировки в ```SpinWait``` с дальнейшим переходом в режим ядра, если блокировку взять не удалось).
</details>

<details>
<summary>
    Блокировка на this, Type, string
</summary>
    
Блокировка на ```this```:
Проблема в том, что ссылка на ```this``` доступна извне вашего объекта. Можно получить проблемы, если кто-то другой возьмет сылку на ваш объект и начнет блокировать по ней. Это приведет к тормозам, в теории может привести к дедлоку.

Блокировка на ```string```:
Все строковые константы (и вычислимые строки типа ```"a" + "b"```) интернируются. Поэтому, если в разных частях программы написать ```"Hello, world!"```, то ссылки будут вести на один объект в пуле интернированных строк. Проблемы могут возникнуть, т.к. это работает даже между доменами приложений. К тому же, если не объявить строку как readonly или const, ее можно будет изменить (путем конкатенации добавить что-то), после чего ссылка на объект поменяется и в ```lock``` можно будет попасть повторно.

Блокировка на ```Type```:
Проблема аналогична одновременно с ```this``` и строками. Во-первых, вы не владеете объектом ```Type``` и кто угодно может на нем заблокироваться. Во-вторых, иногда ```Type``` является разделяемым между доменами приложений, что также приведет к проблеме.

Согласно гайдлайну Microsoft, блокировка на всех трех вышеуказанных объектах не рекомендуется.
</details>

<details>
<summary>Semaphore и SemaphoreSlim</summary>
    
Семафор - примитив синхронизации, предоставляющий доступ к ресурсу множеству потоков (количество варьируется).

Обычный семафор работает на семафорах ядра Windows, ```Slim``` работает на ```SpinWait``` и классе ```Monitor```.

Обычный семафор можно именовать (межпроцессная синхронизация), ```Slim``` нет (внутрипроцессная синхронизация).

```Slim``` считается более легковесной частью, рекомендуется использовать его, когда время ожидания мало (1/4 микросекунды).

В отличие от класса ```Monitor``` или ```ReaderWriterLock```, ведет подсчет проходящих через него потоков (вызвать и снять блокировку можно на разных потоках).
</details>

<details>
<summary>ReaderWriterLock и ReaderWriterLockSlim</summary>
    
Дает множественные права на чтение и монопольные права на запись. Права на чтение выдаются, если не выданы права на запись. Выдача прав на запись блокирует выдачу прав на запись и чтение. Как и ```lock```, требует, чтобы выдача и снятие прав на блокировку происходило в одном потоке.

Обычный класс является устаревшим, сейчас следует использовать версию ```Slim```.

Скорее всего, используется редко, т.к. сценарий "producer-consumer" можно реализовать проще на каналах.
</details>

<details>
<summary>ResetEvent</summary>
    
Несколько классов, всключающие в себя ```ManualResetEvent```, ```ManualResetEventSlim``` и ```AutoResetEvent```.

Метод ```WaitOne``` заставляет поток ожидать "взведения" ивента, метод ```Set``` отпускает зависшие потоки.
Отличие Manual от Auto в том, что Auto автоматически приводится во "взведенное" состояние, пропустив один поток.
</details>

<details>
<summary>Mutex</summary>
Примитив синхронизации, который предоставляет монопольный доступ к ресурсу. Работает на уровне процесса. Именованный mutex работает на уровне ОС. Именованные мьютексы поддерживаются не на всех ОС (точно нет на MacOS, при попытке создать именованный семафор получим исключение в рантайме).
</details>

<details>
<summary>Класс Interlocked</summary>
    
Представляет самый легковесный способ синхронизации. Является низкоуровневым, редко применяется по сравнению с ```lock``` или ```SemaphoreSlim```.
Внутри него статические методы.
```Increment```/```Decrement``` - увеличивает или уменьшает значение переменной
```CompareExchange``` - сравнивает два значения, и если они равны, атомарно заменяет первое вторым и возвращает результат
```Exchange``` - атомарное присваивание значения
```MemoryBarrier``` - запрещает компилятору менять местами инструкции через барьер (компилятор может менять чтения и запись местами ради производительности).

</details>

<details>
<summary>
    Потокобезопасные коллекции
</summary>
    
Лежат в пространстве имен ```System.Collections.Concurrent```.

```ConcurrentDictionary``` - словарь на эффективных блокировках.

```ConcurrentStack```, ```ConcurrentQueue``` - неблокирующие синхронизации.

```BlockingCollection``` - потокобезопасная коллекция элементов с эффективной синхронизацией.

Также потокобезопасными являются неизменяемые коллекции из ```System.Collections.Immutable```, т.к. доступны только на чтение.
</details>

<details>
<summary>
    Для чего используется async/await и Task.Run
</summary>
    
```async/await``` используется для IO-bound операций (ожидание ввода-вывода: ответа на запрос, получения данных из базы).

```Task.Run``` используется для CPU-bound операция (вычисления на процессоре).

Различия связаны с механизмом работы. ```Task.Run``` берет новый поток из пула и говорит ему, что нужно делать; если работа является низкоинтенсивной, поток все равно будет занят. ```async/await``` же компилируется в конечный автомат (машину состояний), которая может пойти по двум веткам выполнения - синхронной и асинхронной; если выполнение пошло по асинхронному пути, то машина позволяет потоку обслуживать другие задачи во время ожидания
</details>

<details>
<summary>
    Для чего используется ValueTask, в чем отличие от Task
</summary>
    
Т.к. ```Task``` - это класс, его использование ведет к выделению памяти на куче и влечет дополнительную работу ```GC```. Среда умная и умеет кэшировать возвращаемые значения, оборачивая их в таск, но кэширование большого количества значений невозможно (например, если возвращаются числа типа ```int```). Следовательно, возвращая простые (уже вычисленные) значения из задач, мы имеем выделение большого количества памяти на куче и тормозим работу приложения ```GC```. Отсутствие выделения памяти в случае синхронного выполнения таска - благо, особенно когда работаем с высоконагруженными сервисами и все максимально файнтюнится.

Для решения проблемы придумали ```ValueTask```. Это структура, которая, если ```Task``` уже завершился, просто обернет ```TResult```, в результате чего никакого выделения на куче не будет вообще; если же выполнение идет асинхронным путем, ```Task``` будет размещен, а ```ValueTask``` его обернет.
</details>

<details>
     <summary>
         Проблемы многопоточных приложений
     </summary>

**Deadlock** - взаимоблокировка потоков, дальнейшее выполнение невозможно.

**Race condition** - состояние гонки, когда результат выполнения программы не всегда детерминирован из-за того, что параллельные потоки влияют друг на друга.

**Thread starvation** - «потоков голод», программа отобрала слишком много рабочих потоков, в результате чего работать стало некому.

**Busy-wait** - проблема, когда слишком много потоков хотят получить доступ к ресурсу, а выполняют вычисление над ресурсом мало потоков (или 1), в результате чего большинство потоков занято просто ожиданием.

</details>

<details>
    <summary>
    Как получить deadlock в C#
    </summary>

Вариантов несколько. Например, вот классический вариант:
Поток 1 занял ресурс А. Поток 2 занял ресурс Б. Поток 1 пытается занять ресурс Б, а поток 2 пытается занять ресурс А. Потоки пытаются занять ресурсы, занятые друг другом, в результате чего происходит взаимоблокировка.
</details>

<details>
    <summary>
        SynchronizationContext - что такое, зачем нужен, как использовать.
    </summary>

Это класс-контракт, используемый для синхронизации (коммуникации) потоков.

- ```SynchronizationContext.Current``` является синглтоном в рамках потока
- Для разработчика работает как очередь сообщений, отправляя делегат асинхронно с помощью ```Post``` или синхронно с помощью ```Send``` для выполнения на целевом потоке
- Отсутствует в ASP .NET Core и консольных приложениях
- Нужен, например, чтобы при желании изменить UI в десктопе из другого потока, нужно было лишь передать контекст синхронизации
- В библиотечном коде можно отключить захват SynchronizationContext используя ```ConfigureAwait(false)```.

Пример. Следующий код выполнится на одном потоке в приложении Windows Forms и на разных в консольном приложении.

```
// thread1 equals thread2 for winforms but probably differ for console app
var thread1 = Environment.CurrentManagedThreadId;

await Task.Delay(1000); // Simulate I/O operation

var thread2 = Environment.CurrentManagedThreadId;
```

</details>

<details>
    <summary>
        Статьи
    </summary>

1. [Базовые понятия многопоточности - Habr](https://habr.com/ru/articles/452094/)
2. [Гайдлайн Microsoft по lock](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/statements/lock)
3. [Примитивы синхронизации - Habr](https://habr.com/ru/articles/459514/)
4. [Потокобезопасные коллекции - StackOverflow](https://ru.stackoverflow.com/questions/1261353\Потокобезопасные-списки-с)
5. [Потокобезопасные коллекции - Habr](https://habr.com/ru/articles/473352/)
6. [Когда использовать Task.Run и async/await - StackOverflow](https://stackoverflow.com/questions/18013523/when-correctly-use-task-run-and-when-just-async-await)
</details>

## Сетевое программирование

<details>
<summary>Проблемы при работе с HttpClient</summary>
Суть проблемы:
    
Если избавиться от ```HttpClient```, то при завершении работы он освобождает ресурс со своей стороны, но с другой стороны мы оставляем сокет в статусе ```TIME_WAIT``` и ждем (вроде на 240с). Проблема называется Socket Exhaustion, когда кончаются доступные сокеты.
Также, если долго держать ```HttpClient``` (например, синглтоном), не будет выполнена ротация DNS, что может быть проблемой для работы с CDN, которые к ней часто прибегают.

Как работает фабрика:
- при вызове ```CreateClient``` создаётся и настраивается новый ```HttpClient```
- под капотом создаются обработчики ```HttpMessageHandler```, которые живут 2 минуты (время можно настроить)
- экземпляры ```HttpMessageHandler``` объединяются в пулы
- проблема устаревания DNS решается путем регулярной утилизации экземпляров HttpMessageHandler
</details> 

<details>
<summary>
HSTS
</summary>

Это заголовок HTTP, информирующий браузер, что попытки обращения по HTTP должны быть конвертированы в HTTPS. Нужен для того, чтобы избежать атаки man-in-the-middle, которая работает с включенным https redirection.
</details>    

<details>
<summary>
Что такое куки и как они работают
</summary>

Cookie - это информация, которую сервер отправляет браузеру. Браузер хранит эту информацию у себя и может посылать ее вместе с запросом в заголовке Cookie.
Куки используются для:
- персонализации
- управление сеансами
- трекинга и т.д.

Ранее куки использовались в качестве хранилища информации, но они потребляют ресурсы, т.к. отправляют их вместе с запросом, поэтому для хранения незащищенной информации можно использовать localStorage.

Схема работы простая. 
1) Сервер создает куки командой SetCookie
2) Браузер хранит куки
3) Куки посылаются с каждым запросом к домену, с которого они были установлены
4) Через какое-то время куки экспайрятся

Параметры куки:
1) Название и значение
2) Срок жизни
3) Secure (чтобы куки передавались только по HTTPS)
4) Домен (с которого куки были отправлены). Для работы с поддоменами здесь обязательно нужно указать корневой домен.
5) HttpOnly - флаг, который делает куки недоступными для JS. При этом их все еще можно послать с запросом.

SameSite может иметь три значения: Strict, Lax и None
Strict - куки посылаются только с запросами с текущего сайта. Например, если есть куки для сайта example.com, при переходе на него с сайта another_example.com по ссылке никакие куки не отправляются.
Lax - куки посылаются при переходе по ссылке напрямую, но не для ajax вызовов.
None - куки посылаются всегда. Это значение должно использоваться с Secure.

</details> 

<details>
<summary>
Что такое JWT-токен, как устроен
</summary>

**JWT** - Json Web Token - стандарт, применяемый для создания токенов доступа на основе JSON. В основном используется для передачи данных об аутентификации на сервер веб-приложения.

Состоит из трех частей: заголовок, пейлоад и подпись. Как правило, представляется в компактном виде, где заголовок и пейлоад закодированы в base64_url, после чего к ним добавляется подпись и все части разделяются точками.

В заголовке 1 необходимое поле alg - алгоритм шифрования подписи. В пейлоаде идет пользовательская информация, обязательных полей нет.

</details>   

<details>
<summary>
Что такое DNS
</summary>

Система доменных имен, которая переводит IP-адрес в понятное буквенное имя (домен). Работает благодаря DNS-серверам, которых в интернете множество.
</details>   

<details>
<summary>
Что такое REST, какие требования
</summary>

Набор правил по организации написания кода. Работает поверх HTTP 1.1.

Требования:
1. Модель клиент-сервер (обмен данными инициирован запросом клиента)
2. Отсутствие состояния (вся требуемая для запроса информация поступает с запросом)
3. Кэширование (для простоты ответы сервера можно кэшировать)
4. Унифицированый интерфейс (HATEOAS - отправка клиенту не только запрошенной информации, но и связей с другими ресурсами и действий) 
5. Многослойная архитектура (ни клиент, ни сервер не знают всю цепочку вызова, максимум своих ближайших соседей)
6. (опционально) Код по требованию (сервер может передать клиенту код для выполнения)

</details>   

<details>
<summary>
Глаголы HTTP, назначение и особенности
</summary>

**GET** - глагол, предназначенный для получения ресурса. Не содержит тела, является идемпотентным.
**POST** - глагол, предназначенный для отправки данных на сервер. Может содержать тело, не является идемпотентным.
**PUT** - глагол, предназначенный для создания или замены ресурса. Может содержать тело, является идемпотентным.
**PATCH** - предназначен для частичного обновления ресурса. Может содержать тело, не является идемпотентным.
**DELETE** - глагол, предназначенный для удаления ресурса. Может содержать тело, является идемпотентным.

Не-идемпотентные запросы нельзя использовать как идемпотентные! Т.е. нельзя изменять ресурсы с помощью GET, т.к. браузер не ожидает такого и может выполнить его несколько раз.

</details>   

<details>
<summary>
Жизненный цикл запроса в ASP .NET Core
</summary>

1. request
2. middleware
3. routing
4. controller init
5. action method exec
6. action result exec
7. middleware
8. response

</details>  

<details>
<summary>
HttpContext
</summary>

Ключевые особенности:
- Контекст текущего запроса, содержащий информацию о нем
- В современном ASP .NET Core нет контекста синхронизации и нет HttpContext.Current, единственным способом получения контекста будет свойство в контроллере или внедрение зависимости, оба метода вернут один и тот же объект
- Не является потокобезопасным: доступ к контексту из разных потоков может привести к неожиданному поведению
- Не должен быть захвачен потоками

</details>

<details>
<summary>
Что такое gRPC
</summary>

**RPC** - удаленный вызов процедур. Использует protobuf для обмена данными. Поток данных как однонаправленный в виде запрос-ответ, так и двунаправленный с помощью стримов. Быстрее, чем REST по бенчмаркам.

Хорошо использовать в микросррвисах, системах с несколькими языками программирования, при потоков передачи данных или сетях с низкой пропускной способностью.

</details>  

<details>
<summary>
Что такое GraphQL, как работает
</summary>

Это синтаксис, описывающий, как запрашивать данные. Работает поверх HTTP. Используется, когда нужно отдавать данные в большом количестве вариаций, чтобы не заводить много эндпоинтов.

Вместо работы с множеством «глупых» эндпоинтов, которые отдают только то, что знают, предлагается 1 «умный» эндпоинт, который обрабатывает запрос на выборку данных и отдает их. Основан на трех компонентах: schema, queries, resolvers

Когда мы просим данные - мы выполняем **запрос**.

**Распознаватель** - помощник, который определяет, как и где взять данные для указанного поля. Не обязательно лезть в бд, поле можно вообще выдумать.

**Схема** - унифицированный язык запросов, благодаря которому все это работает

</details>  


## SQL, ORM

<details>
<summary>
    Что такое внешний ключ?
</summary>
    
Ограничение, используемое для обеспечения целостности связей между таблицами. Является ссылкой на первичный ключ другой таблицы. При вставке значения в «дочернюю» таблицу проверяется наличие соответствующего первичного ключа в «родительской» Если значения нет - ошибка.

</details> 


<details>
<summary>
    Как SQL Server хранит данные
</summary>
    
SQL Server оперирует страницами.
Страница - минимальная ячейка данных в бд, ее размер всегда 8кб (96 байт заголовок + 8096 байт данных).

Устроена следующим образом
| Заголовок (метаданные) | Строки данных | Список ссылок на строки данных |

Одна страница может хранить данные только из одной таблицы. Следовательно, если создать слишком большую строку данных (например, 5000 байт), на странице поместится всего одна строка с данными, остальное место будет потрачено впустую.

</details> 

<details>
<summary>
    В чем отличие HAVING и WHERE?
</summary>
    
HAVING фильтрует на уровне сгруппированных данных, WHERE на уровне исходных.

</details> 

<details>
<summary>
    Что такое ACID, уровни изоляции транзакции
</summary>
    
**ACID** - atomicity, consistency, isolation, durability - набор требований к системе транзакций, обеспечивающий ее наиболее надежную работу.

**Атомарность** - транзакции выполняется целиком либо не выполняется.

**Согласованность** - каждая транзакции фиксирует только допустимые результаты (вообще говоря лежит на плечах прикладного ПО).

**Изоляция** - сокрытие изменений других транзакции при возникновении race condition (параллельные транзакции не должны оказывать влияния на выполнение другой транзакции).

Эффекты, связанные с изоляцией:
1. **Потерянное обновление** (транзакции обновляют одни и те же данные, не учитывая другие транзакции)
Транзакция А изменила значение 1000, добавив к нему 500. До фиксации изменения транзакцией А транзакции Б прочитала баланс, вычла из него 600. Итоговая сумма 400 вместо 900.
2. **Грязное чтение** (чтение данных незавершенных транзакции)
Транзакция А изменила значение 1000, вычла 1000. Транзакции Б проверила значение 0 и отработала. Транзакции А отменилась.
3. **Неповторяемое чтение** (считывание одной и той же строки 2 раза, получение разного результата)
Пусть значение не может уйти в минус. Транзакция А считала значение 1000. Транзакция Б прочитала уменьшила значение на 1000 и зафиксировала изменение. Транзакция А, видя значение 1000, также отнимает 1000, значение уходит в минус.
4. **Фантомное чтение** (набор данных соответствует предикату поиска, но не отображается сразу)
Например, нельзя иметь больше трех счетов. Для открытия счета транзакция А проверяет все счета клиента, видит 2. В этот момент транзакция Б открывает еще один счет.

Для решения проблем есть уровни изоляции:
1. Read uncommitted
2. Read committed
3. Repeatable read
4. Serializable

**Устойчивость** - изменения успешно завершенной транзакции остаются в системе даже после последующего сбоя

Применяется в классических SQL базах данных

</details> 

<details>
<summary>
    BASE
</summary>
    
**BASE** является своего рода противоположностью **ACID** и утверждает, что настоящая согласованность не может быть достигнута.

**B**asically **A**vailable - система всегда доступна и может отдавать устаревшие данные для поддержания доступности
**S**oft state - система может изменить свое состояние, в процессе допускаются некоторые несогласованности
**E**ventual consistency - система станет согласованной со временем

Применяется в NoSQL системах, в распределенных системах, реалтайм аналитике данных и т.п.

</details> 

<details>
<summary>
    Оконные функции
</summary>
    
Оконные функции - специальные функции, работающие с окном (партицией), выполняя вычисления для этого набора строк в отдельном столбце. Не модифицируют выборку, а добавляют к ней значение. Выполняются в конце запроса.

**Партиции** - набор строк, указанные для оконной функции.

</details> 

<details>
<summary>
    Хранимые процедуры, функции, триггеры
</summary>
    
**Хранимые процедуры** - код SQL, который может возвращать, а может не возвращать значение. Нужны для сложной логики, охватывающей несколько действий.

**Триггеры** - особые хранимые процедуры, вызывающиеся по какому-то событию (вставка, удаление данных над таблицей). Нужны для гибкости (например, налоговые надбавки в цене продукта можно считать через триггеры, т.к. их легко изменить/отключить)

**Функции** - код SQL, обязательно возвращающий значение определенного типа.

</details> 

<details>
<summary>
    Что такое индекс в SQL? Какие структуры данных лежат в основе индексов? Какие типы индексов есть?
</summary>
    
**Индекс** - специальная структура данных, ускоряющая поиск в таблице.

При поиске по индексу сначала будет найден сам индекс, затем использует его для быстрого нахождения записи. Без индекса будет выполнено полное сканирование. Индексы бывают кластеризованные и некластеризованные.

Некластеризованный индекс хранит в себе значения индекса и ссылки на строки данных в таблице. Кластеризованный индекс хранит в себе строки целиком. Можно сказать, что кластеризованные индекс - это способ хранения данных в таблице. Следовательно, кластерный индекс может быть 1, некластеризованных много (в районе 1000).

Индекс может быть:
1. Составным (содержит более 1 столба, но не более 16, или длина не более 900 байт)
2. Уникальным (обеспечивает уникальность значений в столбце; автоматически создается при задании первичного ключа или ограничения UNIQUE)
3. Покрывающим (позволяет получить нужные данные сразу с листьев индекса без обращения к записям таблицы)

В качестве структуры данных чаще всего используется сбалансированное дерево (b-tree), но могут и другие (например, bitmap).

Принципы построения индексов:
1. Чем меньше индексов, тем лучше
2. Чем меньше полей в индексе, тем лучше
3. Уникальность значений влияет на индекс
4. Для составного индекса внимание на порядок
5. Обдумать целесообразность введения индекса (если данные часто обновляются, а поиска мало, то индекс не нужен)

</details> 

<details>
<summary>
    Какие минусы есть у внешнего ключа? Всегда ли нужно его использовать?
</summary>
    
Ключевые проблемы:
- при больших нагрузках внешний ключ начинает тормозить выполнение запросов (но система должна быть действительно сильно нагружена).
- поведение ON DELETE фактически является перекладыванием бизнес-логики на хранилище, что с точки зрения system design рассматривается как некорректное.
- при массовых вставках в таблицу проверка целостности внешнего ключа может привести к взаимоблокировкам транзакции.

</details> 

<details>
<summary>
    Различия INNER JOIN и LEFT JOIN
</summary>
    
Оба метода соединения используют одинаковые алгоритмы (merge, hash, nested loops), но при этом есть различия в функциональых и технических аспектах.

**INNER JOIN**
- возвращает только совпадающие значения из обеих таблиц
- оптимизатор может выбрать любой порядок таблиц, из которых он будет вычитывать данные
- может остановить обработку строки, если не найдено совпадение; в целом имеет больше возможностей для оптимизации
- позволяет раннюю фильтрацию на таблице

**LEFT JOIN**
- должен вернуть все значения из левой таблицы, для отсутствия совпадений должен сгенерировать null (в случае отсутствия повторов), с повторами это будут все строки, для которых нашлось совпадение в правой таблице + оставшиеся без совпадения строки из левой с null.
- должен обработать все значения из левой таблицы, чтобы затем искать совпадения в правой
- фильтрация по левой таблице может быть произведена перед соединением, но фильтру по правой может потребоваться выполнение после соединения (```WHERE right.Column1 = 1 OR right.Column1 IS NULL```)

</details> 

<details>
<summary>
     DELETE FROM VS TRUNCATE TABLE
</summary>
    
DELETE FROM удаляет записи из таблицы по одной, блокируя записи по одной и занося каждое удаление в журнал.

TRUNCATE TABLE блокирует таблицу целиком, не заносит удаление каждой записи в журнал, потому работает быстрее.

</details> 

<details>
<summary>
     CAP-теорема
</summary>
    
Одна из главных теорем в распределенных системах, описывающая ее свойства. Утверждается, что можно иметь только 2 свойства из трех, но не все 3 вместе.

**Consistency** - каждое чтение получает самые актуальные данные.

**Availability** - каждый запрос получит ответ от инстанса (если он жив).

**Partition tolerance** - даже если между инстансами нет связи, они продолжают обслуживать клиентов.

CA системы - реляционные СУБД

Master-slave репликация (синхронная или асинхронная). Двухфазный коммит для обеспечения consistency. В случае разделения все slave-ноды начнут отдавать устаревшие данные.

CP системы - MongoDB

Один master-узел с автоматической заменой при отделении обеспечивает consistency. В случае разделения система перестает принимать записи, пока не будет восстановлена связь между узлами.

AP системы - Cassandra 

Использует схему репликации master-master

В основном выбор стоит между AP и CP системами.

Здесь же принцип **PACELC**

Согласно нему, если система разделена (P), то выбор стоит между согласованностью (C) и доступностью (A).
Если система не разделена (E - else), то выбор стоит между задержкой (L - latency) и доступностью (C)

**PA/EL** - приоритет доступности и задержки над согласованностью
**PA/EC** - если есть разделению, выбираем доступность, иначе согласованность
**PC/EL** - если есть разделение, выбираем согласованность, иначе задержку
**PC/EC** - всегда выбираем согласованность

В такой парадигме описанные выше системы имеют следующие характеристики

Cassandra - PA/EL
SQL Server - PC/EC
MongoDb - PA/EC

</details> 

<details>
    <summary>Плюсы и минусы EF Core</summary>

**Плюсы:**
- Linq - удобный способ построения запросов, при этом есть возможность конструирования запросов из «сырого» SQL
- Провайдеры для разных источников данных
- Change tracker для удобного отслеживания изменений в сущностях
- Транзакции
- Подходы code-first и database-first

**Минусы:**
- Получение большого кол-ва данных только для чтения медленно, нужно писать дополнительные методы и отключать change tracker
- Производительность в целом не всегда на высоте
- Использование Contains по коллекции вызывает постоянную перекомпиляцию запроса (бьет и по серверу БД, т.к. надо перестраивать и кэшировать запрос)
- Конфликт миграций при параллельной модификации одной сущности
- Может не оптимальным образом транслировать LINQ в SQL-запрос
</details>
    

<details>
<summary>Различия EF Core и Dapper</summary>

Разницу наглядно демонстрирует таблица:
|  | EF Core | Dapper | 
| ----------- | ----------- | ----------- |
| Функционал | Feature-rich ORM | Micro-ORM |
| Запросы | LINQ, чистый SQL, возможность комбинировать  | Чистый SQL |
| Использование | Много фич, из-за чего имеет свои особенности, которые надо знать, чтобы им полноценно пользоваться | Близок к обычному SQL, легко внедрить |
| Типы | Сильно привязывается к схеме БД, более высокий уровень абстракции  | Не использует сильную типизацию, просто маппит данные в объекты, более низкий уровень абстракции |
| Compile-time ошибки | Базовые ошибки (например, типов) могут быть отловлены в compile-time, но т.к. построение дерева выражения происходит в рантайме, некоторые проблемы могут возникать и в рантайме | Работает с SQL, все проблемы с запросами ловим в рантайме |
| Быстродействие | Работает значительно медленнее из-за трансляции запросов и (самое затратное) change tracker’a. При отключении трекинга EF Core все еще медленнее, но разница становится не такой значительной | Стабильно быстрее и менее прожорлив по памяти, чем EF Core |
| Поддержка СУБД | MS SQL, PostgreSQL, MySQL, Oracle DB, SQLite, MariaDB, Azure SQL, Db2 и другие | MS SQL, PostgreSQL, MySQL, Oracle DB, SQLite |
| Миграции | + | - |

</details>

<details>
    <summary>
        Зачем нужен AsSplitQuery в EF Core
    </summary>

Рассмотрим сценарий

```
var blogs = context.Blogs
.Include(b => b.Posts)
.Include(b => b.Authors)
.ToList();
```

Для данного запроса будет сгенерирован следующий SQL-код

```
SELECT [b].[BlogId], [b].[Url], 
[p].[PostId], [p].[BlogId], [p].[Content], [p].[Title],
[a].[AuthorId], [a].[BlogId], [a].[Name]
FROM [Blogs] AS [b]
LEFT JOIN [Posts] AS [p] ON [b].[BlogId] = [p].[BlogId]
LEFT JOIN [Authors] AS [a] ON [b].[BlogId] = [a].[BlogId]
ORDER BY [b].[BlogId], [p].[PostId], [a].[AuthorId]
```

Для 1 блога с 3 авторами и 5 постами получим 15 записей. Увеличить число блогов до 100, авторов до 300 и постов до 10_000 и получаем комбинаторный взрыв.

Для решения проблемы используется метод ```AsSplitQuery```. Он позволяет получать дочерние сущности отдельным запросом. Для примера выше будут сгенерированы 3 запроса

```
SELECT [b].[BlogId], [b].[Url]
FROM [Blogs] AS [b]
ORDER BY [b].[BlogId]

SELECT [p].[PostId], [p].[BlogId], [p].[Content], [p].[Title], [b].[BlogId]
FROM [Blogs] AS [b]
INNER JOIN [Posts] AS [p] ON [b].[BlogId] = [p].[BlogId]
ORDER BY [b].[BlogId]

SELECT [a].[AuthorId], [a].[BlogId], [a].[Name], [b].[BlogId]
FROM [Blogs] AS [b]
INNER JOIN [Authors] AS [a] ON [b].[BlogId] = [a].[BlogId]
ORDER BY [b].[BlogId]
```

Таким образом, для 1 блога с 3 авторами и 5 постами вместо 15 записей получи 1+3+5=9 записей. 

</details>

<details>
    <summary>
        Когда EF Core генерирует INNER JOIN для дочерних сущностей, а когда LEFT JOIN
    </summary>

LEFT JOIN используется, когда
- дочерние сущности достаются одним запросом (т.к. необходимо вернуть главную сущность с или без дочерних)
- отношение опционально, дочерних сущностей может не быть

INNER JOIN используется, когда
- применяется AsSplitQuery
- применяется IsRequired при конфигурации отношения
- применяется фильтрация родительских сущностей на наличие хотя бы одной дочерней сущности (```.Where(parent => parent.Children.Any()```) 
    
</details>

<details>
    <summary>
        Методы загрузки дочерних сущностей в EF Core
    </summary>

Существует три типа загрузки данных:

1) **Eager loading** - явная загрузка данных через ```Include```

Загружает все данные из бд сразу. Используется, когда загружаемые данные нужны сразу после запроса для всех или почти всех сущностей.

Предсказуемый перформанс, хороший для ограниченного набора данных, но уменьшается по мере увеличения количества данных. Все данные доступны сразу же после выполнения запроса.
Однако, если вложенные сущности обрабатываются не для всех запрошенных родительских сущностей, то мы загружаем больше данных, чем надо.

2) **Lazy loading** - ленивая загрузка данных при первом обращении к навигационному свойству, настраивается через ```UseLazyLoadingProxies```

Данные загружаются из базы при первом обращении к навигационному свойству. Можно использовать, когда данные по вложенным сущностям нужны редко или неизвестно наперед, будут ли они нужны.

Перформанс предсказать сложно, также можно попасть на проблему N+1, когда для N родительских сущностей каждое последующее обращение к дочерней сущности генерирует новый запрос к бд.

3) **Explicit loading** - загрузка данных вручную через ```Load``` после загрузки основной сущности.

Полный контроль за загрузкой дочерних сущностей. Позволяет точечно загружать свойства для сущностей в условиях неопределенности. Используется, когда нужен полный контроль над загружаемыми сущностями.

При бездумном использовании также может привести к проблеме N+1. По очевидным причинам сложнее в написании.

4) **Projection loading** - загрузка проекций с указанными полями, а не сущностей целиком (```.Select(x => new MyDto { Name = x.FullName })```)

Позволяет оптимизировать чтение путем выборкии только нужных полей. Change Tracker не вносит импакт (т.к. не  работаееат для проекций). Позволяет как угодно преобразовать данные для проекции. Используется для передачи данных в видео DTO. 

Для сложных структур и запросов может генерироваться неэффективный SQL. Также возможно вытягивание дублирующихся данных.

**Выводы**
 использовать eager loading для известных ограничений по данным
- использовать lazy loading крайне осторожно, чтобы не попасть на проблему N+1
- использовать проекции, когда нужны только конкретные поля
- для сложных сценариев использовать батчинг

</details>

<details>
    <summary>
        Как читать и вставлять/обновлять миллионы записей в бд
    </summary>

Для чтения
- использовать Bulk операции (пакеты типа **BulkExtensions**, метод ```BulkRead```)
- использовать EF Core с выключенным трекингом или Dapper + добавить батчинг
- использовать низкоуровневый ```DataReader``` (в крайних случаях)

Для вставки/обновления
- использовать Bulk операции для EF Core (```BulkInsert```, ```BulkUpdate```)
- обратить внимание на индексы в таблице, которые могут замедлять вставку/обновление

</details>


## ООП, проектирование

<details>
<summary>
    Какие паттерны проектирования использовал? Опишите юзкейсы. Где в .NET можно встретить эти паттерны?
</summary>
    
**Стратегия** - когда мы хотим изменять внутренний алгоритм работы в зависимости от каких-то условий путем делегирования функционала вовне. Например, стратегия сравнения элементов в LINQ ```IEqualityComparer```.

**Состояние** - когда поведение объекта зависит от его внутреннего состояния. Например, состояния Task.

**Фабрика** - абстрагирование от создания объектов, внесение полиморфизма в создание объектов. Статические фабрики в ```TimeSpan```, ```HttpClientFactory```, ```Task.Factory```, фасадная фабрика ```File.Create```.

**Cинглтон** - когда мы хотим ограничить число экземпляров. Такими бывают сервисы в DI, глобальный кэш.

**Адаптер** - когда мы совмещаем два несовместимых интерфейса. LINQ-провайдеры, ```TextReader```/```TextWriter``` являются адаптерами над ```Stream```.

**Фасад** - представление унифицированного интерфейса вместо набора интерфейсов подсистем. ```File.Create```

**Посредник** - позволяет реализовать общение объектов без необходимости ссылаться друг на друга. Любая форма в WinForms есть посредник, в паттерне MVC контроллер есть посредник.

**Команда** - позволяет определять команду на выполнение действия как объект. Помогает реализовать потоковую обработку, отмену запросов и т.п. ```Task``` принимает делегат ```Func```, который будет использован для получения результата задачи.

**Шаблонный метод** - переопределение этапов алгоритма без изменения его структуры, а также вынесение общей части алгоритма в шаблонный метод. ```ChannelBase``` в WCF

**Цепочка обязанностей** - позволяет выстраивать получателей в цепочку, каждый из получателей обработает запрос и передаст дальше. Событие ```Closing``` в Windows Forms.

</details> 

<details>
<summary>Композиция vs наследование</summary>
Наследование и композиция помогают выделить общий функционал классов, а также построить иерархию классов.

Наследование.
Все дочерние классы имеют функционал базового класса, но при этом сильно зависят от него.
Полиморфизм - могут быть использованы как "базовый" тип.
Иерархия - **is-a**
Можно наследоваться только от одного класса
Изменения в базовом классе ведут к изменениям в дочерних классах, не всегда такие изменения совместимы с текущей иерархией, могут сломать дочерние классы.

Композиция.
Класс содержит другие классы с реализациями общего функционала.
Связь менее тесная, так как работа ведется через интерфейсы, реализацию можно подменить в рантайме.
Проще тестировать, так как интерфейсы можно мокнуть
Нет ограничения с одним классом, как в наследовании
Иерархия - **has-a**

Утрированный пример, как ломаются иерархии наследования (немного перекликается с **I** и **L** из **SOLID**)
Нужно добавить поддержку для ласточки, сороки и колибри. Выделяем базовый класс **Птица**. Предполагаем, что птица умеет летать, в базовый класс добавляем метод **Fly**. 
В какой-то момент просят добавить пингвина. **Пингвин** - это **Птица**, но не умеет летать. Следовательно, переделываем иерархию.
С композицией у нас был бы интерфейс **IFlyer**. **Пингвин** содержал бы в себе этот интерфейс с реализацией **NoFly**.

Еще пример хрупкости наследования.
Базовый класс **Персонаж** с абстрактными **Attack** и **Move**.
Делаем класс **Воин**, который атакует мечом. Добавляем ходящего и плавающего воинов.
Итого - для двух воинов имеем 4 класса. Комбинаторный взрыв, когда для реализации n функциональностей нам нужно 2^n классов
Проблема ромбовидного наследования - что делать, если нужен воин, который и плавает, и ходит?
Решением было бы выделить 2 интерфейса **IMovable** и **IAttacker**. Создать класс игрок, который содержит реализации этих интерфейсов. Внутри класса можно создать тип (WalkingWarrior, SwimmingWarrior и т.д.), по типу создавать реализации через фабрику.
</details>

<details>
<summary>Основные принципы ООП</summary>

**Инкапсуляция** - скрытие внутреннего состояния и функций объекта и предоставление доступа через открытый набор методов.

**Наследование** - возможность создания новых абстракций на основе существующих.

**Полиморфизм** - возможность реализации наследуемыех свойств и методов различными способами в рамках множества абстракций.

**Абстракция** - моделирование требуемых атрибутов сущности реального мира в виде сущности кода с достаточным уровнем точности.
</details>

<details>
<summary>Полиморфизм в C#</summary>
    
Полиморфизм бывает трех типов:

1) Параметрический
Реализуется за счет дженериков.

2) Полиморфизм подтипов
Реализуется за счет наследования путем переопределения/сокрытия методов базового класса дочерними. Позднее связывание (в процессе выполнения).

3) Специальный (ad hoc)
Достигается за счет перегрузки методов. Раннее связывание.
    
</details>

<details>
<summary>SOLID</summary> 

Набор правил, сформулированных как рекомендации для написания «чистого» кода

**S** - Single responsibility - единственная ответственность

Каждый класс должен иметь единственную зону ответственности - не совсем точная трактовка, т.к. в такой трактовке принцип недостижим даже теоретически. Программа представляет собой дерево, сходящееся буквально к нескольким классам, которым ничего не остается кроме управления большим количеством функционала.

В «чистом коде» формулирует так: Модуль должен иметь только одну причину для изменения. Иначе говоря, модуль должен обслуживать только одну заинтересованную группу.

**O** - Open/closed - открытость-закрытость
Объекты должны быть открыты для расширения и закрыты для модификации.
Простой пример - switch по какому-то значению, после чего вызываются разные методы. Для соблюдения OCP нужно создать класс, соответствующий каждому значению, после чего вызывать методы уже без switch.

**L** - Liscov substitution - подстановка Лисков
Рекомендация по определению иерархии объектов.
Дочерние сущности должны соблюдать контракт, предоставляемый родительской сущностью. Не усиливать предусловия, не ослаблять постусловия, сохранять инварианты, не бросать исключения, которые не ожидаются в родительском классе.

**I** - Interface segregation - разделение интерфейсов
Объект не должен зависеть от интерфейса, который он не реализует. Типичный признак - в классе есть методы интерфейса, которые не используются (игнорируются, кидается исключение; такое поведение нарушает и LSP).

**D** - Dependency inversion - инверсия зависимостей
Модули верхнего уровня не зависят от модулей нижнего уровня, все они зависят от абстракций. Абстракции не зависят от деталей - детали зависят от абстракций.
Суть в использовании интерфейсов и внедрения зависимостей.dependency 
</details>

<details>
<summary>DRY, KISS, YAGNI, BDUF</summary>
    
Аббревиатуры, обозначающие один из принципов:
**DRY** - Don’t Repeat Yourself - не повторяйся (дублирование кода - это плохо, придется поддерживать его в двух и более местах одинаковый).

**KISS** - Keep It Simple, Stupid - будь проще (зачем делать сложно если можно сделать просто?).

**YAGNI** - You Aren’t Gonna Need It - тебе это не понадобится (отказ от избыточной функциональности).

**BDUF** - Big Design Up Front - глобальное проектирование прежде всего (если неполностью спроектировать систему, то почти наверняка придется решать проблемы проектирования кодом - костыли, кривые решения).
    
</details>

<details>
<summary>
    Монолит, микросервисы и сервис-ориентированная архитектура: плюсы и минусы
</summary>

Ключевые различия в таблице:
|  | Монолит | Сервис-ориентированная | Микросервисы | 
| ----------- | ----------- | ----------- | ----------- | 
| Отказоустойчивость | Одна ошибка может положить все приложение | Сляжет сервис, что больнее, чем на микросервисах, но лечге, чем на монолите | Ошибка уложит один сервис, не повлияв на остальные |
| Язык программирования | Пишется на одном языке | Один язык в рамках одного сервиса | Один язык в рамках одного сервиса |
| Управление релизами | Сложное, требуется полная перепубликация | Средняя, перепубликация сервиса не сложна | Легкая, перепубликация сервиса очень быстра |
| Проектирование | Легкое | Легкое | Бывает весьма трудным |
| Поддержка контрактов | Не требуется | Не требуется | Требуется |
| Распределенные транзакции | Не требуется | Не требуется | Если да, то это головная боль |
| Поиск ошибок | Легкий | Легкий | Как правило затруднен |
| Скорость отклика | Высокая | Высокая | Низкая |
| Трудность развертывания | Низкая | Средняя | Высокая |
| Стоимость разработки/поддержки | Низкая | Средняя | Высокая |
| Гибкость | Низкая | Средняя | Высокая |
| Масштабируемость | Низкая | Средняя | Высокая |

</details>

<details>
<summary>
    Виды архитектуры приложений
</summary>

**Трехслойная архитектура**
Содержит три слоя:
1. Доступ к данным - модели данных, миграции, иногда добавляются интерфейсы репозиториев
2. Бизнес-логика - все сервисы и бизнес-модели
3. Клиентская логика - UI или контроллеры, middleware
Все зависимости идут сверху вниз, зависимости снизу вверх отсутствуют (например, слой данных не зависит от бизнес логики).

**Чистая архитектура**
Также разделяется на 3 слоя:
1. Слой ядра приложения - содержит модели данных, а также доменные сервисы, события и т.п.
2. Инфраструктурный слой - кэши данных, доступ к хранилищу данных, прочие сервисы (например, сервис по отправке электронных писем)
3. Клиентский слой - UI или контроллеры, middleware
Зависимости также идут сверху вниз, доменный код не зависит от инфраструктурного кода. В таком случае, для доменного кода легко писать тесты, т.к. фактически нет зависимостей от других слоев.

**Vertical slices**
Вместо использования слоев, в которых может находиться много несвязанного между собой кода (речь про не связанные доменные модели/сервисы), предлагается использовать срезы, которые расположены перпендикулярно слоям. Срез содержит в себе все, что требуется для ответа на запрос клиента. В таком подходе отпадает необходимость во введении большого количества абстракций - внутри среза можно выстроить наиболее быстрый/удобный путь выполнения запроса.
Часто используется совместно с CQRS.

</details>

<details>
<summary>
    Каким образом микросервисы могут общаться между собой?
</summary>

Синхронное общение (запрос-ответ):
1. REST
- легко написать
- легко вызвать
- легко для понимания
- если сервис-получатель запроса лежит - ошибка, нельзя отложить выполнение запроса
- нет схемы данных
- текстовый формат порождает много лишних данных (ключ-значение в json)
2. gRPC
- отправка запроса выглядит как вызов метода в коде
- есть схема данных
- бинарный формат данных protobuf
- есть поддержка стриминга
3. SOAP
- xml

Асинхронное общение:
1. Месседжинг (RabbitMQ)
- асинхронный формат общения
- работает по принципу проталкивания сообщения читателям
- удаляет сообщение после обработки
- может реализовать сложную архитектуру маршрутизации сообщений
2. Стриминг (Kafka)
- асинхронный формат общения
- работает по принципу вытягивания сообщения из топика читателями
- перерабатывает титанические объемы данных, хорошо масштабируется
- хранит сообщения на диске до момента плановой очисти журнала

</details>

<details>
<summary>
    Как разделять монолит на микросервисы?
</summary>

Микросервисы создаются по таким паттернам:
1. Разбиение по бизнес-возможностям: выделяются границы бизнес-возможностей приложения и каждому действию выделяется свой сервис
2. Разбиение по поддоменам: в рамках одного сервиса выделяют некую логически связную часть домена

Паттерны распила монолита на микросервисы:
1. Душитель - постепенный перенос существующих возможностей на микросервисы с интеграцией их функционала в монолит; постепенно весь функционал уйдет в сервисы.
2. Слой защиты от повреждений - частичный переход на микросервисы в случае, когда рефакторинг некоторых систем долгий или невозможный в принципе. Вводится специальный слой, который преобразует данные из модели старой части системы в модель новую и наоборот.

</details>

<details>
<summary>
    Статьи
</summary>

1. [SOLID - Habr](https://habr.com/ru/articles/508086/)
(Переход на микросервисы - Mail)[https://mcs.mail.ru/blog/26-osnovnyh-patternov-mikroservisnoj-razrabotki]
2. [микросервисы vs монолит vs сервис-ориентированная архитектура - Skillbox](https://skillbox.ru/media/code/servicebased-architecture-sem-raz-otmer-odin-raz-popili-monolit/)
3. [Общение микросервисов - Habr](https://habr.com/ru/companies/maxilect/articles/677128/)
4. [Kafka & RabbitMQ - TProger](https://tproger.ru/articles/pochemu-my-ispolzuem-kafka-vmesto-rabbitmq-sravnenie-i-preimushhestva)

</details>

## Отвлеченные темы

<details>
<summary>
    TCP & UDP
</summary>

TCP:
1. устанавливает соединение перед отправкой (рукопожатием) 
2. контроль порядка пакетов
3. надежность передачи данных
4. медленнее UDP
5. из-за надежности требует больше данных в заголовке
UDP:
1. не требует рукопожатия
2. не контролирует порядок или доставку пакетов
3. быстрее TCP
4. меньше заголовок

</details>

<details>
<summary>
    Симметричное, асимметричное шифрование, хэширование
</summary>

**Симметричное** - ключ, используемый для шифрования данных, используется и для дешифровки.
Требования - статистических закономерностей и линейности в зашифрованном сообщении быть не должно.
Бывают блочные и поточные. Блочные делят сообщение на блоки и шифруют их. Поточные формируют выходную гамму, в процессе генерации которой происходит шифрование.

**Асимметричные** - шифрование и дешифрование используют разные ключи.

**Хэширование** - не используется ключ, кодирование происходит с помощью математических операций.

</details>

<details>
<summary>
    Хорошие и плохие алгоритмы шифрования
</summary>

**MD5** - алгоритм хэширование, предпосылки к взлому появились еще в 90-ых, сейчас популярность падает.

**SHA1/2** - алгоритм хэширования, генерирующий 160-битное значение хэша. Лежит в основе многих алгоритмов и протоколов.

**Rijnadel (AES)** - симметричный алгоритм блочного шифрования. Размер блока 128 бит, 128/192/256 бит ключи. Популярный алгоритм шифрования и в наши дни.

**DES** - симметричный блочный алгоритм шифрования с блоком 64 бита. Сейчас считается небезопасным.

**RC4** - потоковый шифр, широко применяющийся в различных криптосистемах и защите информации (SSL/TLS). Быстро работает, поддерживает переменный размер ключа. Уязвим к не случайному ключу или переиспользованию ключевого потока. Сейчас использовать не рекомендуется.

**Диффи-Хеллман** - один из первых асимметричных алгоритмов. Сейчас не используется, т.к. Были обнаружены уязвимости типа «человек посередине».

**RSA** - асимметричный алгоритм, один из самых популярных. Основан на том, что нет простого способа найти разложение большого числа на простые множители. Для поддержания стойкости с увеличением вычислительных мощностей нужно увеличивать размер ключа. Мнения по алгоритму расходятся.

**ECC** - криптография с эллиптическими кривыми. Может предложить уровень стойкости RSA при гораздо меньшем размере ключей.

</details>

<details>
<summary>
    Статьи
</summary>

1. [TCP/UDP - Habr](https://habr.com/ru/articles/711578/)
2. [TCP/UDP - cloud4y](https://www.cloud4y.ru/blog/tcp-vs-udp/)
3. [Устаревание RSA - Habr](https://habr.com/ru/companies/virgilsecurity/articles/459370/)
4. [Хорошие и плохие алгоритмы шифрования - proverkassl](https://proverkassl.com/book_algoritm_glossary.html)

</details>

## Задачи на код:
<details>
    <summary>Задача 1</summary>

Дан класс. Описать, что он делает, что можно поменять.
```
public class MyClass
{
    public string filePath;

    public void set_path(string path)
    {
        filePath = path;
    }

    public string read_file_utf8()
    {
        var result = "";
        var reader = new StreamReader(filePath, Encoding.UTF8);
        while (!reader.EndOfStream)
        {
            result += reader.ReadLine();
            result += "\n";
        }
        return result;
    }

    public string read_file_utf32()
    {
        var result = "";
        var reader = new StreamReader(filePath, Encoding.UTF32);
        while (!reader.EndOfStream)
        {
            result += reader.ReadLine();
            result += "\n";
        }
        return result;
    }
}
```

Проблемы:
1. Имя класса не говорящее
2. Именование методов не из мира C#
3. Имеем 2 одинаковых метода, отличающиеся параметром кодировки. Лучше сделать 1 метод, который принимает котировку как параметр.
4. В публичное поле (которому не надо быть публичным) устанавливается значение не конструктором, а void-методом, что неправильно, нужен конструктор. При этом если оставить 1 конструктор и 1 метод, то пользоваться классом будет не очень удобно. Проще оставить 1 статический метод, который принимает 2 параметра: кодировку и путь до файла.
5. Если файл большой, то конкатенация строк в результат может быть долгой, лучше использовать ```StringBuilder```
6. ```StreamReader``` следует обернуть в ```using```.
7. Не на всех ОС перенос строки реализуется с помощью «\n», иногда это другой символ. Лучше заменить на ```Environment.NewLine```

Итог:
```
public class FileReader
{
    public static string ReadFileWithEncoding(string filePath, Encoding encoding)
    {
        var result = new StringBuilder();
        using (var reader = new StreamReader(filePath, encoding))
        {
            while (!reader.EndOfStream)
            {
                result.Append(reader.ReadLine());
                result.Append(Environment.NewLine);
            }
        }
        return result.ToString();
    }
}
```
    
</details>

<details>
    <summary>Задача 2</summary>

Требуется написать класс, в котором происходит параллельный запрос в сеть (запрос в бд, к апи, etc.) с ограничением в N одновременных запросов.
Для примера возьмем N=3.

```
public class ApiCaller()
{
    private readonly SemaphoreSlim _semaphore = new(3);

    public async Task MakeParallelApiCalls()
    {
        var urls = new[]
        {
            "https://api.example.com/endpoint1",
            "https://api.example.com/endpoint2",
            "https://api.example.com/endpoint3",
            "https://api.example.com/endpoint4",
            "https://api.example.com/endpoint5"
        };

        var cts = new CancellationTokenSource(TimeSpan.FromSeconds(10));
        var token = cts.Token;

        var tasks = urls.Select(x => QueryNetworkAsync(x, token));

        var results = await Task.WhenAll(tasks);

        for (int i = 0; i < results.Length; i++)
        {
            Console.WriteLine($"Result from {urls[i]}: {results[i]}");
        }
    }

    private async Task<char?> QueryNetworkAsync(string url, CancellationToken cancellationToken)
    {
        await _semaphore.WaitAsync(cancellationToken);

        try
        {
            // imitate some IO bound work, throw when network is unavailable
            await Task.Delay(2_000, cancellationToken);
            var willThrow = Random.Shared.Next(0, 2) == 1;
            if (willThrow)
                throw new Exception();

            return url.Last();
        }
        catch (Exception ex)
        { 
            // can either log or return result with error so the caller can decide what to do next
            return null;
        }
        finally
        {
            _semaphore.Release();
        }
    }
}

```

Примечания:
1) При запросах в бд с EF Core нужно использовать ```IDbContextFactory``` и создавать контекст в каждом потоке, так как DbContext не потокобезопасен и выбрасывает исключение при попытке выполнения двух и более одновременных операций
2) При запросах в сеть используем ```IHttpClientFactory```, не создаем клиентов вручную. Основные методы ```HttpClient``` потокобезопасны. Главное - корректно создать и задиспоузить ```HttpClient```.

</details>

<details>
    <summary>
Задача 3
    </summary>
    
Существует три метода, которые меняют информацию о товаре(изменяют состояние, изменяют состов тегов и задает вес).
Так как в дальнейшем планируется добавить еще 10-20 методов которые меняют информацю о товаре(сами методы могут быть реализованы как nuget в другом сервисе)
нужно реализовать единственный метод DoSomethingWithItem который в зависимости от входных параметров мог бы вызывать любое изменение товара.
То есть методу может быть сказано "Поменяй состояние" или "Задай вес"

```
public class Product
{
    public int Id { get; set; }
    public string Name { get; set; }
    public double Weight { get; set; }
    public string[] Tags { get; set; }
    public bool IsActive { get; set; }
}
```


Для решения воспользуемся паттернами команда и строитель.

```
public interface IProductCommand
{
    ValueTask ExecuteAsync(Product product);
}

// each command can be async for a number of reasons
// all the dependencies and parameters are passed via constructor
public class UpdateWeightCommand : IProductCommand
{
    public ValueTask ExecuteAsync(Product product)
    {
        product.Weight = 1;
        return ValueTask.CompletedTask;
    }
}

public class UpdateStateCommand : IProductCommand
{
    public ValueTask ExecuteAsync(Product product)
    {
        product.IsActive = true;
        return ValueTask.CompletedTask;
    }
}

public class UpdateTagsCommand : IProductCommand
{
    public ValueTask ExecuteAsync(Product product)
    {
        product.Tags = [];
        return ValueTask.CompletedTask;
    }
}

public class CompositeCommand(IEnumerable<IProductCommand> commands) : IProductCommand
{
    public async ValueTask ExecuteAsync(Product product)
    {
        foreach (var command in commands)
        {
            await command.ExecuteAsync(product);
        }
    }
}
```

Небольшой билдер для команд

```
public class ProductCommandBuilder
{
    private readonly ICollection<IProductCommand> _commands = [];

    public ProductCommandBuilder UpdateWeight()
    {
       _commands.Add(new UpdateWeightCommand());
        return this;
    }

    public ProductCommandBuilder UpdateTags()
    {
        _commands.Add(new UpdateTagsCommand());
        return this;
    }

    public ProductCommandBuilder UpdateState()
    {
        _commands.Add(new UpdateStateCommand());
        return this;
    }

    public IProductCommand Build() => new CompositeCommand(_commands);
}
```
Класс, выполняющий команду. В теории, реализация никогда не поменяется.

```
public class ProductUpdateService
{
    // could return operation result here
    public async Task DoSomethingWithItemAsync(IProductCommand command)
    {
        if (command is null)
            return;

        try
        {
            // start transaction
            // obtain product from db, redis, etc
            var product = new Product();

            await command.ExecuteAsync(product);

            //commit transaction
        }
        catch (Exception ex)
        {
            // log error, rollback transaction
        }
    }
}
```

Клиент для апдейтера
```
internal class ProductUpdateServiceClient
{
    public async Task UpdateGoodAsync()
    {
        var command = new ProductCommandBuilder()
            .UpdateWeight()
            .UpdateState()
            .UpdateTags()
            .Build();

        var service = new ProductUpdateService();

        await service.DoSomethingWithItemAsync(command);
    }
}
```
</details>
